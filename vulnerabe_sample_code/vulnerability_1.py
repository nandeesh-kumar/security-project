import os
import sqlite3
import pickle
import re
import random
from flask import Flask, request

# 1. Hardcoded credentials (Bad practice)
USERNAME = "admin"
PASSWORD = "password123"

# 2. Insecure Flask web app (XSS & SQL Injection)
app = Flask(__name__)
conn = sqlite3.connect(':memory:', check_same_thread=False)
cursor = conn.cursor()
cursor.execute("CREATE TABLE users (username TEXT, password TEXT)")
cursor.execute("INSERT INTO users VALUES ('admin', 'password123')")

@app.route("/login", methods=["GET"])
def login():
    # 3. SQL Injection
    username = request.args.get("username")
    password = request.args.get("password")
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    result = cursor.execute(query).fetchall()
    return f"<h1>Query result:</h1><pre>{result}</pre>"

@app.route("/greet", methods=["GET"])
def greet():
    # 4. Cross-Site Scripting (XSS)
    name = request.args.get("name", "")
    return f"<h1>Hello, {name}!</h1>"

@app.route("/load", methods=["POST"])
def load():
    # 5. Insecure Deserialization
    data = request.data
    obj = pickle.loads(data)  # Dangerous: can execute arbitrary code!
    return f"Loaded object: {obj}"

@app.route("/file", methods=["GET"])
def read_file():
    # 6. Path Traversal
    filename = request.args.get("file", "default.txt")
    with open(f"files/{filename}", "r") as f:
        return f.read()

@app.route("/eval", methods=["GET"])
def eval_user_input():
    # 7. Use of eval (arbitrary code execution)
    expression = request.args.get("expr", "")
    result = eval(expression)
    return f"Result: {result}"

@app.route("/regex", methods=["GET"])
def vulnerable_regex():
    # 8. Regex Denial of Service (ReDoS)
    pattern = request.args.get("pattern", "a+" )
    text = request.args.get("text", "a" * 10000 )
    if re.match(pattern, text):
        return "Matched!"
    return "Not matched."

@app.route("/random", methods=["GET"])
def insecure_random():
    # 9. Insecure randomness (predictable tokens)
    token = str(random.randint(100000, 999999))
    return f"Your token: {token}"

@app.route("/error", methods=["GET"])
def error_leak():
    # 10. Improper error handling (information leak)
    try:
        1 / 0
    except Exception as e:
        return f"Error occurred: {e}"  # Leaks internal error

if __name__ == "__main__":
    app.run(debug=True)
